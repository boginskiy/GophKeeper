# GophKeeper
GophKeeper - Сервис облачное хранилище данных.

### Описание
GophKeeper представляет собой клиент-серверную систему, позволяющую пользователю надёжно и безопасно хранить данные.

Сервер реализует следующую бизнес-логику:
    регистрация, аутентификация и авторизация пользователей
    хранение данных
    передача данных владельцу по запросу

Клиент реализует следующую бизнес-логику:
    аутентификация и авторизация пользователей на удалённом сервере
    доступ к данным по запросу

Клиент распространяется в виде CLI-приложения.

### Установка дополнительных зависимостей
Для работы диалогового окна
```
sudo apt install python3-tk
```

### Особенности

#### Регистрация и авторизация

- Сохранение пользовательских данных

При регистрации пользователь вводит данные, которые сохраняются в config.json.
Примерное местоположение файла:
```
~/home/ali/.config/gophclient/config.json
```

При пользовании необходимо авторизоваться путем ввода электронной почты и пароля. Приложение осуществит сверку данных с данными последней успешной сессии и осуществит авторизацию на удаленном сервере.

- Восстановление доступа

Предусмотрено восстановление пароля через одноразовый код по электронной почте.

- Повторный ввод данных

Предусмотрен повторный ввод данных при их несоответствии с данными config.json. 
При превышении лимита попыток приложение потребует новую регистрацию

MaxRetries - параметр командной строки. Отвечает за количество попыток.
```
go run ./cmd/gophclient/main.go -m 3
```

#### Обработка и передача данных

- Типы загружаемых данных

Приложение работает с контентом типа bytes, text, image, sound, video

- Передача данных

Загрузка и выгрузка контента осуществляется через stream gRPC.

#### Безопасность

- Криптографическая подпись данных

В рамках гарантированной доставки файлов при загрузке и выгрузке осуществляется проверка контрольных сумм (HMAC, SHA-256).


#### Хранение данных

- Загрузка контента на сервер

Загружаемые данные сохраняются в файловой системе сервера в директории "store" с учетом имени пользователя. Метаданные сохраняются в базе данных.

- Выгрузка контента в клиента

Выгружаемые данные сохраняются в рабочей области клиентского приложения в директории "store" с учетом типа файла.


#### Валидация данных

- Проверка загружаемого контента

При загрузки контента клиентское приложение осуществляет валидацию по типу файла.


#### Общее

- Диалог CLI

Ввод команд осуществляется через диалоговое окно. При возникновении ошибок, необходимо прописать абсолютный путь до файла. 

- Shutdown

Предусмотрена система мягкой остановки клиентского приложения.



#### TODO ...
Шифрование данных.
Integration tests
Unit tests
Сборка

- OTP
- БД на стороне клиента. Синхронизация данных с сервером
- Применяйте очереди заданий (RabbitMQ, Kafka) для снижения пиковых нагрузок
- Валидация пользовательских данных
- Продумать логику MaxRetries для записей в БД



#### ERROR ...
- Сделать поле "name" уникальным для таблицы texts, bytes,
- не грузит картинки с русскими названиями. Возможно все медиа не будет грузить с русскими названиями.
- При прерывании регистрации, запись может остаться в БД, потмоу что она может быть сделана на момент прерывания.
- При регистрации другого пользователя, программа не помнит предыдущего, из-за этого надо заново регистрироваться.
- Если удалить конфиг с данными по клиенту, то клиент будет проходить регистрацию
и не сможет зарегаться, потому что в базе данных он есть. Восстановление доступа ?
- При повторной регистрации и если есть уже запись этого пользователя, сервер дает ошибку
ведь запрос на регистрацию. Надо проверить данные и если все верно выдать токен и т.п.
- Срок жизни одноразового кода, при восстановлении учетки.



#### Attention
- errgroup для структурной конкурентности, os.Root для безопасной работы с файлами, log/slog для логирования. Эти штуки реально упростили бы код

- В стиле Go есть косяки: сокращения типа Logg, Hdlr, Srv, так не принято; константы капсом вместо MixedCaps

- По архитектуре: handlers знают о protobuf типах (нарушение Clean Architecture), много дублирования кода обработки ошибок, Service Locator в Init() вместо DI